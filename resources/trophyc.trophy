union Token {
    eof         as void;
    plus        as void;
    minus       as void;
    multiply    as void;
    open_paren  as void;
    close_paren as void;
    int_literal as int;
};

union Result {
    error   as void;
    success as int;
};

struct String {
	bytes as span[int];
};

struct NamedSyntax {
	name as String;
	expr as Syntax;
};

union BinaryOperator {
	op_multiply as void;
	op_divide as void;
	op_add as void;
	op_subtract as void;
	op_and as void;
	op_or as void;
	op_xor as void;
	op_lessthan as void;
	op_lessthan_eq as void;
	op_greaterthan as void;
	op_greaterthan_eq as void;
	op_eq as void;
	op_neq as void;
};

union UnaryOperator {
	op_not as void;
	op_plus as void;
	op_minus as void;
};

struct UnarySyntax {
	op as UnaryOperator;
	arg as Syntax;
};

struct BinarySyntax {
	op as BinaryOperator;
	left as Syntax;
	right as Syntax;
};

union Syntax {
	void_literal as void;
	int_literal as int;
	bool_literal as bool;
	value_access as String;
	var_access as String;
	
	if_expr as span[Syntax];	
	while_expr as span[Syntax];
	block_expr as span[Syntax];
	ref binary_expr as BinarySyntax;	
	ref unary_expr as UnarySyntax;
	
	assign_stat as span[Syntax];
	ref var_stat as NamedSyntax;
	ref ref_stat as NamedSyntax;
	ref new_var_stat as NamedSyntax;
	ref new_ref_stat as NamedSyntax;
};

union TypeSyntax {
	parse_error as void;
	identifier as String;
	ref span_expr as TypeSyntax;
	ref array_expr as TypeSyntax;
	ref var_expr as TypeSyntax;
	ref ref_expr as TypeSyntax;
};

union TrophyType {
	int_type as void;
	bool_type as void;
	void_type as void;
	
	ref array_type as TrophyType;
	ref span_type as TrophyType;
	ref var_type as TrophyType;
	ref ref_type as TrophyType;

	struct_type as String;
	union_type as String;
	
	singular_function_type as String;
	function_type as span[TrophyType];
};

struct Lexer {
	tokens as span[Token];
	var pos as int;
	
	func peek (lex as Lexer) as Token => {
		lex.tokens[lex.pos];
	};
	
	func next (lex as Lexer) as Token => {
		if lex.pos < lex.tokens.size then {
			ref tok = lex.tokens[lex.pos];
			lex.@pos = lex.pos + 1;
			
			tok;
		}
		else put Token { eof };
	};
};

func type_expr (lex as Lexer) as TypeSyntax => variable_type_expr(lex);

func variable_type_expr (lex as Lexer) as TypeSyntax => {
	ref tok = lex.peek();

	if (tok is var_keyword) or (tok is ref_keyword) 
							or (tok is span_keyword) 
							or (tok is array_keyword) then {
				
		# Advance on the keyword
		lex.next();
				
		# Eat an open bracket
		if lex.next() is not open_bracket do {
			return void;
		};
		
		# Parse the inner expression
		ref inner = type_expr(lex);
		if inner is parse_error do {
			return void;		
		};
		
		# Eat a close bracket
		if lex.next() is not close_bracket do {
			return void;
		};
		
		match tok 
			if var_keyword then put TypeSyntax { var_expr=@inner }
			if ref_keyword then put TypeSyntax { ref_expr=@inner }
			if span_keyword then put TypeSyntax { span_expr=@inner }
			if array_keyword then put TypeSyntax { array_expr=@inner };
	}
	else {
		type_atom(lex);
	};
};

func type_atom (lex as Lexer) as TypeSyntax => {
	if lex.peek() is identifier id then put TypeSyntax { identifier=id }
	else void;
};

func parse (input as span[int]) as int => {
    var pos = 0;
	
	region R {
		ref toks = chars_to_tokens(input);
	
		return match add_expr(toks, @pos)
			if success s then s
			else 0;
	};
};

func chars_to_tokens (toks as span[int]) as span[Token] => {
    ref result = new array[Token] { size=toks.size+1 };
    var result_pos = 0;

    for i = 0 to toks.size-1 do {
        if toks[i] != 32 do {
            result@[result_pos] = char_to_token(toks[i]);
            @result_pos = result_pos + 1;
        };
    };

    result;
};

func char_to_token (c as int) as Token => {
    if c == 40                      then put Token { open_paren }
    else if c == 41                 then put Token { close_paren }
    else if c == 43                 then put Token { plus }
    else if c == 45                 then put Token { minus }
    else if c == 42                 then put Token { multiply }
    else if (c >= 48) and (c <= 57) then put Token { int_literal=c-48 }
    else void;
};


func add_expr (toks as span[Token], var pos as int) as Result => {
	if mult_expr(toks, @pos) is not success first do {
		return void;
	};
	
    while (toks[pos] is plus) or (toks[pos] is minus) do {
        ref op = toks[pos];
        @pos = pos + 1;

		if mult_expr(toks, @pos) is not success next do {
			return void;
		};

        @first = if op is plus
            then first + next
            else first - next;
    };

    first;
};

func mult_expr (toks as span[Token], var pos as int) as Result => {
	if atom(toks, @pos) is not success first do {
		return void;
	};

    while toks[pos] is multiply do {
        @pos = pos + 1;

		if atom(toks, @pos) is not success next do {
			return void;
		};

        @first = first * next;
    };
    
    first;
};

func atom (toks as span[Token], var pos as int) as Result => {
    if toks[pos] is open_paren then {
        @pos = pos + 1;

        ref result = add_expr(toks, @pos);

        if toks[pos] is not close_paren do {
			return void;
		};
		
		@pos = pos + 1;
		result;
    }
    else if toks[pos] is int_literal then {
        var value = 0;

        while toks[pos] is int_literal i do {
            @value = 10 * value + i;
            @pos = pos + 1;
        };

        value;
    }
    else void;
};